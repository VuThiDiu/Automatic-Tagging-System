# -*- coding: utf-8 -*-
"""AutomateTaggingImageClothes_update.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LBiip2IJPSuDgjwKy6e3YedoMh6VCtDP
"""

import numpy as np
import pandas as pd
import os 
import glob
import matplotlib.pyplot as plt
from logging import error
from sklearn.utils import shuffle
import tensorflow as tf
from tensorflow.keras.utils import to_categorical
from PIL import Image
from keras.layers.convolutional import Conv2D
from keras.models import Sequential,Model,load_model
from tensorflow.keras.optimizers import SGD
from keras.layers import BatchNormalization, Lambda, Input, Dense, Convolution2D, MaxPooling2D, AveragePooling2D, ZeroPadding2D, Dropout, Flatten, merge, Reshape, Activation
from keras.layers.merge import Concatenate
from keras.preprocessing.image import ImageDataGenerator
from keras.callbacks import ModelCheckpoint
from keras.layers import Input
from tensorflow.keras.optimizers import Adam
import numpy as np

dataset_folder_name = "E:\Crawler\change\color"
train_test_split = 0.8
image_width = image_height = 200

#tag predict 
os.chdir("E:\Crawler\change\color")
dataset_dict = {
    'color_id' : {
        0:'trắng', 
        1:'hồng', 
        2:'đỏ',
        3:'cam', 
        4:'vàng',
        5:'xanh',
        6:'xám',
        7: 'đen' 
    },
}


dataset_dict['color_alias'] = dict((g,i) for i, g in dataset_dict['color_id'].items())
# extracting the data from the dataset
def parse_dataset(dataset_path):

  """ 
  Use to extract information about our dataset. It does interate over all images 
  and return a DataFrame with the data (category, color, gender, isAdult) of all files.
  """
  def parse_into_from_file(path):
    """
    Parse information from a single file
    """
    try:
      filename = os.path.split(path)[1]
      filename = os.path.splitext(filename)[0]
      filename = filename.split(' ')[0]
      listname = filename.split('_')
      category,color,gender,isAdult = listname[0], listname[1], listname[2], listname[3]
      return dataset_dict['color_id'][int(color)], listname[1]
    except Exception as ex:
      pass
  files = os.listdir(dataset_path)
  records = []
  for file in files:
    info = parse_into_from_file(file)
    records.append(info)

  df = pd.DataFrame(records)
  df['file'] = files
  df.columns = ['color', 'color_id',  'file']

  return df


df = parse_dataset(dataset_folder_name)
df.head()

# data visualization
import plotly.graph_objects as go

def plot_distribution(pd_series):
  labels = pd_series.value_counts().index.tolist()
  counts = pd_series.value_counts().values.tolist()

  pie_plot = go.Pie(values=counts, labels=labels, hole=0.5)
  fig = go.Figure(data = [pie_plot])
  fig.update_layout(title_text = 'Distribution for %s' %pd_series.name)

  fig.show()

# plot_distribution(df['color'])


# data generator
"""
In order to input data to our Keras multi-output model, we will create a helper 
object to wr=ork as a data generator for out dataset. 
"""

#index 
print("starting generate image ")

print("starting get index")
p = np.random.permutation(len(df))
# train_up_to = int(len(df) * train_test_split)
# train_idx = p[:train_up_to]
# test_idx = p[train_up_to:]

# train_up_to = int(train_up_to * train_test_split)
# train_idx, valid_idx = train_idx[:train_up_to], train_idx[train_up_to:]

train_up_to = int(len(df) * train_test_split)
train_idx =  p[:train_up_to]
valid_idx =  p[train_up_to:]

print("starting get array image")
def generate_images(image_idx):
    """
    Using to generate a batch with images when training/ testing/ validating our Keras model
    """

    images, colors= [],  []
    for idx in image_idx:
      cloth = df.iloc[idx]          
      color = cloth['color_id']
      file = cloth['file']

      im = Image.open(file).convert('RGB')
      im = im.resize((image_width, image_height))
      im = np.array(im) / 255.0
      try:
        if int(color) <= max(dataset_dict['color_id']) and int(color) >= 0:
          colors.append(to_categorical(color,len(dataset_dict['color_id'])).astype("uint8"))
          images.append(im)
        else :
          continue
      except Exception as err:
        print(error)
    return shuffle(images, colors)

print("starting with valid dataset")
print(len(valid_idx))
validX, validY = generate_images(valid_idx)

print("starting with training dataset")
print(len(train_idx))
trainX, trainY = generate_images(train_idx)
# print("starting with test dataset")
# print(len(test_idx))
# testX, testY = generate_images(test_idx)


trainX = np.array(trainX)
trainY = np.array(trainY)

# testX = np.array(testX)
# testY = np.array(testY)

validX = np.array(validX)
validY = np.array(validY)


# input_training = Input(shape=(image_width,image_height, 3))
# top_conv1 = Conv2D(filters=48,kernel_size=(11,11),strides=(4,4),
#                             input_shape=(255,255,3),activation='relu')(input_training)
# top_conv1 = BatchNormalization()(top_conv1)
# top_conv1 = MaxPooling2D(pool_size=(3,3),strides=(2,2))(top_conv1)

# top_top_conv2 = Lambda(lambda x : x[:,:,:,:24])(top_conv1)
# top_bot_conv2 = Lambda(lambda x : x[:,:,:,24:])(top_conv1)

# top_top_conv2 = Convolution2D(filters=64,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(top_top_conv2)
# top_top_conv2 = BatchNormalization()(top_top_conv2)
# top_top_conv2 = MaxPooling2D(pool_size=(3,3),strides=(2,2))(top_top_conv2)

# top_bot_conv2 = Convolution2D(filters=64,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(top_bot_conv2)
# top_bot_conv2 = BatchNormalization()(top_bot_conv2)
# top_bot_conv2 = MaxPooling2D(pool_size=(3,3),strides=(2,2))(top_bot_conv2)

# # concat 2 features map
# top_conv3 = Concatenate()([top_top_conv2,top_bot_conv2])
# top_conv3 = Convolution2D(filters=192,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(top_conv3)

# #split feature map by half
# top_top_conv4 = Lambda(lambda x : x[:,:,:,:96])(top_conv3)
# top_bot_conv4 = Lambda(lambda x : x[:,:,:,96:])(top_conv3)

# top_top_conv4 = Convolution2D(filters=96,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(top_top_conv4)
# top_bot_conv4 = Convolution2D(filters=96,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(top_bot_conv4)

# top_top_conv5 = Convolution2D(filters=64,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(top_top_conv4)
# top_top_conv5 = MaxPooling2D(pool_size=(3,3),strides=(2,2))(top_top_conv5) 

# top_bot_conv5 = Convolution2D(filters=64,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(top_bot_conv4)
# top_bot_conv5 = MaxPooling2D(pool_size=(3,3),strides=(2,2))(top_bot_conv5)

# top_top_conv5 = Convolution2D(filters=64,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(top_top_conv4)
# top_top_conv5 = MaxPooling2D(pool_size=(3,3),strides=(2,2))(top_top_conv5) 

# top_bot_conv5 = Convolution2D(filters=64,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(top_bot_conv4)
# top_bot_conv5 = MaxPooling2D(pool_size=(3,3),strides=(2,2))(top_bot_conv5)

# # Bottom branch
# bottom_conv1 = Convolution2D(filters=48,kernel_size=(11,11),strides=(4,4),
#                             input_shape=(255,255,3),activation='relu')(input_training)
# bottom_conv1 = BatchNormalization()(bottom_conv1)
# bottom_conv1 = MaxPooling2D(pool_size=(3,3),strides=(2,2))(bottom_conv1)

# # second bottom convolution layer
# # split feature map by half
# bottom_top_conv2 = Lambda(lambda x : x[:,:,:,:24])(bottom_conv1)
# bottom_bot_conv2 = Lambda(lambda x : x[:,:,:,24:])(bottom_conv1)

# bottom_top_conv2 = Convolution2D(filters=64,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(bottom_top_conv2)
# bottom_top_conv2 = BatchNormalization()(bottom_top_conv2)
# bottom_top_conv2 = MaxPooling2D(pool_size=(3,3),strides=(2,2))(bottom_top_conv2)

# bottom_bot_conv2 = Convolution2D(filters=64,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(bottom_bot_conv2)
# bottom_bot_conv2 = BatchNormalization()(bottom_bot_conv2)
# bottom_bot_conv2 = MaxPooling2D(pool_size=(3,3),strides=(2,2))(bottom_bot_conv2)

# # third bottom convolution layer
# # concat 2 feature map
# bottom_conv3 = Concatenate()([bottom_top_conv2,bottom_bot_conv2])
# bottom_conv3 = Convolution2D(filters=192,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(bottom_conv3)

# # fourth bottom convolution layer
# # split feature map by half
# bottom_top_conv4 = Lambda(lambda x : x[:,:,:,:96])(bottom_conv3)
# bottom_bot_conv4 = Lambda(lambda x : x[:,:,:,96:])(bottom_conv3)

# bottom_top_conv4 = Convolution2D(filters=96,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(bottom_top_conv4)
# bottom_bot_conv4 = Convolution2D(filters=96,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(bottom_bot_conv4)

# # fifth bottom convolution layer
# bottom_top_conv5 = Convolution2D(filters=64,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(bottom_top_conv4)
# bottom_top_conv5 = MaxPooling2D(pool_size=(3,3),strides=(2,2))(bottom_top_conv5) 

# bottom_bot_conv5 = Convolution2D(filters=64,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same')(bottom_bot_conv4)
# bottom_bot_conv5 = MaxPooling2D(pool_size=(3,3),strides=(2,2))(bottom_bot_conv5)

# #concanate top and bottom branch
# conv_output = Concatenate()([top_top_conv5,top_bot_conv5,bottom_top_conv5,bottom_bot_conv5])

# # Flatten
# flatten = Flatten()(conv_output)

# # Fully-connected layer
# FC_1 = Dense(units=4096, activation='relu')(flatten)
# FC_1 = Dropout(0.6)(FC_1)
# FC_2 = Dense(units=4096, activation='relu')(FC_1)
# FC_2 = Dropout(0.6)(FC_2)
# FC_2 = Dense(units = 8, activation='softmax')(FC_2)
# model = Model(inputs = input_training, outputs = FC_2)
# model.summary()
model = Sequential()
model.add(Conv2D(32, (3,3), input_shape = (image_height,image_width,3), padding = "same"))
model.add(Conv2D(32, (3,3), input_shape = (image_height,image_width,3), padding = "same"))

model.add(Activation("relu"))
model.add(BatchNormalization())

model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Activation("relu"))
model.add(BatchNormalization())


model.add(Conv2D(32, (3,3), input_shape = (image_height,image_width,3), padding = "same"))
model.add(Activation("relu"))
model.add(BatchNormalization())

model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Activation("relu"))
model.add(BatchNormalization())

# model.add(Dropout(0.25))
# model.add(Activation("relu"))
# model.add(BatchNormalization())

model.add(Conv2D(64, (3,3), padding = "same"))
model.add(Activation("relu"))
model.add(BatchNormalization())

model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Activation("relu"))
model.add(BatchNormalization())

model.add(Conv2D(32, (3,3), input_shape = (image_height,image_width,3), padding = "same"))
model.add(Activation("relu"))
model.add(BatchNormalization())

model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Activation("relu"))
model.add(BatchNormalization())

# model.add(Dropout(0.25))
# model.add(Activation("relu"))
# model.add(BatchNormalization())

model.add(Conv2D(64, (3,3), padding = "same"))
model.add(Activation("relu"))
model.add(BatchNormalization())

model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Activation("relu"))
model.add(BatchNormalization())

# model.add(Dropout(0.25))
# model.add(Activation("relu"))
# model.add(BatchNormalization())

# model.add(Conv2D(128, (3,3), padding = "same"))
# model.add(Activation("relu"))
# model.add(BatchNormalization())

# model.add(Dropout(0.4))
# model.add(Activation("relu"))
# model.add(BatchNormalization())

model.add(Flatten())
model.add(Dense(64))
model.add(Activation("relu"))
model.add(BatchNormalization())

model.add(Dropout(0.5))
model.add(Activation("relu"))
model.add(BatchNormalization())

model.add(Dense(8))
model.add(Activation("softmax"))

model.summary()

learning_rate = 0.001
epochs = 50

opt = Adam(learning_rate = learning_rate)
model.compile(loss= "mean_squared_error",
               optimizer = opt,
               metrics = ['accuracy'])

from tensorflow.python.util import nest


# aug = ImageDataGenerator(rotation_range=0.18, zoom_range=0.15, width_shift_range= 0.2, height_shift_range=0.2, horizontal_flip=True, input_shape=(image_height, image_width, 2))
batch_size = 64
valid_batch_size = 64

print("starting training")
history = model.fit(
    # aug.flow(trainX, trainY, batch_size=batch_size),
    trainX, trainY,
    steps_per_epoch=len(train_idx)//batch_size,
    batch_size=batch_size, 
    epochs=epochs,
    validation_data=(validX, validY),
    validation_steps=len(valid_idx)//valid_batch_size,
    verbose = 1)
model.save("../color.h5")

#accuracy for color
plt.clf()
fig = go.Figure()
fig.add_trace(go.Scatter(
    y=history.history['accuracy'],
    name='Train'
))
fig.add_trace(go.Scatter(
    y=history.history['val_accuracy'],
    name='Valid'
))
fig.update_layout(
    height=500,
    width=700,
    title='Accuracy for color feature',
    xaxis_title='Epoch',
    yaxis_title='Accuracy'
)
fig.show()


#test data

# test_batch_size = 128
# correct_prediction = 0
# incorrect_prediction = 0
# number_data_test = len(testX)
# for x in range(0,number_data_test):
#   predict = model.predict(testX[x])
#   print(predict)
#   if (predict == testY[x]) : correct_prediction+=1
#   else : incorrect_prediction+=1
# print ("accuracy for test data : ", correct_prediction/number_data_test)